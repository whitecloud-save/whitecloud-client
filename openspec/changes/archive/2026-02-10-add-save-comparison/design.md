## 上下文
用户需要在游戏存档管理中快速识别当前存档与已备份存档是否一致，避免重复备份或错误的回滚。当前系统存档备份存储为 ZIP 文件，但无法判断内容是否相同。

### 约束
- 必须保证对比的准确性和可靠性
- 大存档（>10MB）的对比性能必须可接受（<50ms）
- 不能破坏现有的存档备份和回滚功能
- 数据库变更必须使用 synchronize 模式自动同步

### 利益相关者
- 最终用户：需要快速判断存档是否一致
- 开发团队：需要维护代码质量和性能

## 目标 / 非目标

### 目标
- 提供准确、快速的存档对比功能
- 支持大存档的高性能对比
- 保持向后兼容性
- 使用缓存避免重复计算，提高性能

### 非目标
- 存档文件级别的差异展示（仅判断是否一致）
- 自动检测存档变化并触发备份
- 跨主机的存档对比
- 实时监控存档变化

## 决策

### 决策 1：使用缓存机制
**选择**：在 Game 类使用私有变量 `currentSave_` 缓存与当前存档一致的最新备份

**理由**：
- 避免每次调用都重新计算哈希（20-50ms），提升性能
- 仅在必要时更新缓存（初始化、备份、回滚、同步）
- 实现简单，通过公共方法 `getCurrentSave()` 访问缓存
- 符合单一职责原则，Game 类管理自己的缓存

**考虑的替代方案**：
- 每次调用都重新计算：性能差
- 使用全局缓存：增加耦合度，不利于维护
- 在 Save 类缓存：Save 类不应管理当前存档状态

### 决策 2：缓存更新时机
**选择**：在以下时机更新缓存
- Game 初始化时（软件启动、远端游戏同步）
- 创建新存档时（自动备份、手动备份）
- 存档回滚后

**理由**：
- 初始化时确保缓存有效
- 备份和回滚是唯一会改变当前存档内容的场景
- 避免频繁更新，减少计算开销

**考虑的替代方案**：
- 定时轮询更新：不必要，浪费资源
- 监听文件系统事件：复杂度高，不可靠
- 用户手动刷新：用户体验差

### 决策 3：双层检查机制
**选择**：先检查目录大小，再比较目录哈希

**理由**：
- 大小不同可以立即返回（<10ms），覆盖绝大多数情况
- 哈希计算仅在小数情况需要，性能可控
- 实现简单，代码清晰

**考虑的替代方案**：
- 仅使用哈希对比：不够高效
- 仅使用大小对比：不够准确
- 增量哈希计算：复杂度高，收益有限

### 决策 4：不压缩直接计算目录哈希
**选择**：对存档目录中的所有文件直接计算哈希，不先压缩

**理由**：
- 压缩是主要性能瓶颈（300-1000ms for 10MB）
- 直接哈希仅需 20-50ms，性能提升 10-20 倍
- 哈希能够精确反映文件内容变化

**考虑的替代方案**：
- 先压缩再哈希：性能太差
- 仅存储 ZIP 文件哈希：无法对比未压缩存档
- 选择性哈希（仅关键文件）：不完整，可能遗漏

### 决策 5：存储三个哈希字段
**选择**：directoryHash（目录哈希）、zipHash（ZIP哈希）、directorySize（未压缩大小）

**理由**：
- `directoryHash`：用于快速对比当前存档（核心功能）
- `zipHash`：用于验证 ZIP 文件完整性（可选扩展）
- `directorySize`：用于第一层快速筛选

**考虑的替代方案**：
- 仅存储 directoryHash：无法进行大小筛选
- 仅存储 zipHash：无法对比未压缩存档

### 决策 6：在 Game 类而非 Save 类添加 getCurrentSave()
**选择**：在 Game 类添加 getCurrentSave() 方法

**理由**：
- Game 类管理所有存档，更自然的归属
- 避免在 Save 类增加过多职责
- Game 类可以访问当前存档目录，便于对比
- 缓存机制适合放在 Game 类中

**考虑的替代方案**：
- 在 Save 类添加 compareWithCurrent()：增加 Save 类职责

## 风险 / 权衡

### 风险 1：现有存档缺少哈希字段
**缓解措施**：新字段为可选（nullable），现有存档的哈希值为 null，不影响现有功能

### 风险 2：哈希计算可能影响备份性能
**缓解措施**：
- 哈希计算开销小（20-50ms）
- 仅在备份时计算一次，不影响回滚性能
- 使用缓存机制避免重复计算

### 风险 3：文件顺序影响哈希一致性
**缓解措施**：
- 对文件列表按路径排序后再计算哈希
- 确保相同目录结构生成相同哈希

### 风险 4：缓存失效场景
**缓解措施**：
- 仅在明确会改变当前存档的场景更新缓存
- 如果缓存失效，用户可以重启应用重新初始化
- 后续可考虑添加手动刷新功能

## 迁移计划

### 步骤
1. 添加三个新字段到 SaveDB（nullable）
2. 运行构建同步数据库结构
3. 实现工具方法（calculateDirectoryHash、calculateDirectorySize）
4. 在 Game 类添加缓存变量和方法
5. 修改 Game.init() 在初始化时计算缓存
6. 修改 Game.zipSave() 计算并存储哈希，然后更新缓存
7. 修改 Save.rollback() 通知 Game 更新缓存
8. 修改 GameService.importRemoteGame() 更新缓存
9. 测试验证

### 回滚
- 新字段为可选，不影响现有功能
- 缓存为私有变量，移除后不影响功能
- 如有问题，可移除相关代码保留字段

## 待决问题
- 是否需要在 UI 层展示"与当前一致"标记？（待定）
- 是否需要提供手动刷新缓存的功能？（待定）
